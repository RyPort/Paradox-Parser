// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v3.6.1
// source: connectionless_netmessages.proto

package deadlock

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type C2S_CONNECT_SameProcessCheck struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	LocalhostProcessId *uint64                `protobuf:"varint,1,opt,name=localhost_process_id,json=localhostProcessId" json:"localhost_process_id,omitempty"`
	Key                *uint64                `protobuf:"varint,2,opt,name=key" json:"key,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *C2S_CONNECT_SameProcessCheck) Reset() {
	*x = C2S_CONNECT_SameProcessCheck{}
	mi := &file_connectionless_netmessages_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *C2S_CONNECT_SameProcessCheck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*C2S_CONNECT_SameProcessCheck) ProtoMessage() {}

func (x *C2S_CONNECT_SameProcessCheck) ProtoReflect() protoreflect.Message {
	mi := &file_connectionless_netmessages_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use C2S_CONNECT_SameProcessCheck.ProtoReflect.Descriptor instead.
func (*C2S_CONNECT_SameProcessCheck) Descriptor() ([]byte, []int) {
	return file_connectionless_netmessages_proto_rawDescGZIP(), []int{0}
}

func (x *C2S_CONNECT_SameProcessCheck) GetLocalhostProcessId() uint64 {
	if x != nil && x.LocalhostProcessId != nil {
		return *x.LocalhostProcessId
	}
	return 0
}

func (x *C2S_CONNECT_SameProcessCheck) GetKey() uint64 {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return 0
}

type C2S_CONNECT_Message struct {
	state                     protoimpl.MessageState        `protogen:"open.v1"`
	HostVersion               *uint32                       `protobuf:"varint,1,opt,name=host_version,json=hostVersion" json:"host_version,omitempty"`
	AuthProtocol              *uint32                       `protobuf:"varint,2,opt,name=auth_protocol,json=authProtocol" json:"auth_protocol,omitempty"`
	ChallengeNumber           *uint32                       `protobuf:"varint,3,opt,name=challenge_number,json=challengeNumber" json:"challenge_number,omitempty"`
	ReservationCookie         *uint64                       `protobuf:"fixed64,4,opt,name=reservation_cookie,json=reservationCookie" json:"reservation_cookie,omitempty"`
	LowViolence               *bool                         `protobuf:"varint,5,opt,name=low_violence,json=lowViolence" json:"low_violence,omitempty"`
	EncryptedPassword         []byte                        `protobuf:"bytes,6,opt,name=encrypted_password,json=encryptedPassword" json:"encrypted_password,omitempty"`
	Splitplayers              []*CCLCMsg_SplitPlayerConnect `protobuf:"bytes,7,rep,name=splitplayers" json:"splitplayers,omitempty"`
	AuthSteam                 []byte                        `protobuf:"bytes,8,opt,name=auth_steam,json=authSteam" json:"auth_steam,omitempty"`
	ChallengeContext          *string                       `protobuf:"bytes,9,opt,name=challenge_context,json=challengeContext" json:"challenge_context,omitempty"`
	LocalhostSameProcessCheck *C2S_CONNECT_SameProcessCheck `protobuf:"bytes,10,opt,name=localhost_same_process_check,json=localhostSameProcessCheck" json:"localhost_same_process_check,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *C2S_CONNECT_Message) Reset() {
	*x = C2S_CONNECT_Message{}
	mi := &file_connectionless_netmessages_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *C2S_CONNECT_Message) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*C2S_CONNECT_Message) ProtoMessage() {}

func (x *C2S_CONNECT_Message) ProtoReflect() protoreflect.Message {
	mi := &file_connectionless_netmessages_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use C2S_CONNECT_Message.ProtoReflect.Descriptor instead.
func (*C2S_CONNECT_Message) Descriptor() ([]byte, []int) {
	return file_connectionless_netmessages_proto_rawDescGZIP(), []int{1}
}

func (x *C2S_CONNECT_Message) GetHostVersion() uint32 {
	if x != nil && x.HostVersion != nil {
		return *x.HostVersion
	}
	return 0
}

func (x *C2S_CONNECT_Message) GetAuthProtocol() uint32 {
	if x != nil && x.AuthProtocol != nil {
		return *x.AuthProtocol
	}
	return 0
}

func (x *C2S_CONNECT_Message) GetChallengeNumber() uint32 {
	if x != nil && x.ChallengeNumber != nil {
		return *x.ChallengeNumber
	}
	return 0
}

func (x *C2S_CONNECT_Message) GetReservationCookie() uint64 {
	if x != nil && x.ReservationCookie != nil {
		return *x.ReservationCookie
	}
	return 0
}

func (x *C2S_CONNECT_Message) GetLowViolence() bool {
	if x != nil && x.LowViolence != nil {
		return *x.LowViolence
	}
	return false
}

func (x *C2S_CONNECT_Message) GetEncryptedPassword() []byte {
	if x != nil {
		return x.EncryptedPassword
	}
	return nil
}

func (x *C2S_CONNECT_Message) GetSplitplayers() []*CCLCMsg_SplitPlayerConnect {
	if x != nil {
		return x.Splitplayers
	}
	return nil
}

func (x *C2S_CONNECT_Message) GetAuthSteam() []byte {
	if x != nil {
		return x.AuthSteam
	}
	return nil
}

func (x *C2S_CONNECT_Message) GetChallengeContext() string {
	if x != nil && x.ChallengeContext != nil {
		return *x.ChallengeContext
	}
	return ""
}

func (x *C2S_CONNECT_Message) GetLocalhostSameProcessCheck() *C2S_CONNECT_SameProcessCheck {
	if x != nil {
		return x.LocalhostSameProcessCheck
	}
	return nil
}

type C2S_CONNECTION_Message struct {
	state                     protoimpl.MessageState        `protogen:"open.v1"`
	AddonName                 *string                       `protobuf:"bytes,1,opt,name=addon_name,json=addonName" json:"addon_name,omitempty"`
	LocalhostSameProcessCheck *C2S_CONNECT_SameProcessCheck `protobuf:"bytes,2,opt,name=localhost_same_process_check,json=localhostSameProcessCheck" json:"localhost_same_process_check,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *C2S_CONNECTION_Message) Reset() {
	*x = C2S_CONNECTION_Message{}
	mi := &file_connectionless_netmessages_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *C2S_CONNECTION_Message) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*C2S_CONNECTION_Message) ProtoMessage() {}

func (x *C2S_CONNECTION_Message) ProtoReflect() protoreflect.Message {
	mi := &file_connectionless_netmessages_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use C2S_CONNECTION_Message.ProtoReflect.Descriptor instead.
func (*C2S_CONNECTION_Message) Descriptor() ([]byte, []int) {
	return file_connectionless_netmessages_proto_rawDescGZIP(), []int{2}
}

func (x *C2S_CONNECTION_Message) GetAddonName() string {
	if x != nil && x.AddonName != nil {
		return *x.AddonName
	}
	return ""
}

func (x *C2S_CONNECTION_Message) GetLocalhostSameProcessCheck() *C2S_CONNECT_SameProcessCheck {
	if x != nil {
		return x.LocalhostSameProcessCheck
	}
	return nil
}

var File_connectionless_netmessages_proto protoreflect.FileDescriptor

const file_connectionless_netmessages_proto_rawDesc = "" +
	"\n" +
	" connectionless_netmessages.proto\x12\bdeadlock\x1a\x11netmessages.proto\"b\n" +
	"\x1cC2S_CONNECT_SameProcessCheck\x120\n" +
	"\x14localhost_process_id\x18\x01 \x01(\x04R\x12localhostProcessId\x12\x10\n" +
	"\x03key\x18\x02 \x01(\x04R\x03key\"\x88\x04\n" +
	"\x13C2S_CONNECT_Message\x12!\n" +
	"\fhost_version\x18\x01 \x01(\rR\vhostVersion\x12#\n" +
	"\rauth_protocol\x18\x02 \x01(\rR\fauthProtocol\x12)\n" +
	"\x10challenge_number\x18\x03 \x01(\rR\x0fchallengeNumber\x12-\n" +
	"\x12reservation_cookie\x18\x04 \x01(\x06R\x11reservationCookie\x12!\n" +
	"\flow_violence\x18\x05 \x01(\bR\vlowViolence\x12-\n" +
	"\x12encrypted_password\x18\x06 \x01(\fR\x11encryptedPassword\x12H\n" +
	"\fsplitplayers\x18\a \x03(\v2$.deadlock.CCLCMsg_SplitPlayerConnectR\fsplitplayers\x12\x1d\n" +
	"\n" +
	"auth_steam\x18\b \x01(\fR\tauthSteam\x12+\n" +
	"\x11challenge_context\x18\t \x01(\tR\x10challengeContext\x12g\n" +
	"\x1clocalhost_same_process_check\x18\n" +
	" \x01(\v2&.deadlock.C2S_CONNECT_SameProcessCheckR\x19localhostSameProcessCheck\"\xa0\x01\n" +
	"\x16C2S_CONNECTION_Message\x12\x1d\n" +
	"\n" +
	"addon_name\x18\x01 \x01(\tR\taddonName\x12g\n" +
	"\x1clocalhost_same_process_check\x18\x02 \x01(\v2&.deadlock.C2S_CONNECT_SameProcessCheckR\x19localhostSameProcessCheckB4Z2github.com/RyPort/paradox-parser/deadlock;deadlock"

var (
	file_connectionless_netmessages_proto_rawDescOnce sync.Once
	file_connectionless_netmessages_proto_rawDescData []byte
)

func file_connectionless_netmessages_proto_rawDescGZIP() []byte {
	file_connectionless_netmessages_proto_rawDescOnce.Do(func() {
		file_connectionless_netmessages_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_connectionless_netmessages_proto_rawDesc), len(file_connectionless_netmessages_proto_rawDesc)))
	})
	return file_connectionless_netmessages_proto_rawDescData
}

var file_connectionless_netmessages_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_connectionless_netmessages_proto_goTypes = []any{
	(*C2S_CONNECT_SameProcessCheck)(nil), // 0: deadlock.C2S_CONNECT_SameProcessCheck
	(*C2S_CONNECT_Message)(nil),          // 1: deadlock.C2S_CONNECT_Message
	(*C2S_CONNECTION_Message)(nil),       // 2: deadlock.C2S_CONNECTION_Message
	(*CCLCMsg_SplitPlayerConnect)(nil),   // 3: deadlock.CCLCMsg_SplitPlayerConnect
}
var file_connectionless_netmessages_proto_depIdxs = []int32{
	3, // 0: deadlock.C2S_CONNECT_Message.splitplayers:type_name -> deadlock.CCLCMsg_SplitPlayerConnect
	0, // 1: deadlock.C2S_CONNECT_Message.localhost_same_process_check:type_name -> deadlock.C2S_CONNECT_SameProcessCheck
	0, // 2: deadlock.C2S_CONNECTION_Message.localhost_same_process_check:type_name -> deadlock.C2S_CONNECT_SameProcessCheck
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_connectionless_netmessages_proto_init() }
func file_connectionless_netmessages_proto_init() {
	if File_connectionless_netmessages_proto != nil {
		return
	}
	file_netmessages_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_connectionless_netmessages_proto_rawDesc), len(file_connectionless_netmessages_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_connectionless_netmessages_proto_goTypes,
		DependencyIndexes: file_connectionless_netmessages_proto_depIdxs,
		MessageInfos:      file_connectionless_netmessages_proto_msgTypes,
	}.Build()
	File_connectionless_netmessages_proto = out.File
	file_connectionless_netmessages_proto_goTypes = nil
	file_connectionless_netmessages_proto_depIdxs = nil
}
